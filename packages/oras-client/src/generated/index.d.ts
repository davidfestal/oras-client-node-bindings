/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class OrasClient {
  /** Create a new OCI client */
  constructor(insecure?: boolean | undefined | null)
  /**
   * Pull an image manifest from the registry.
   * Returns: JSON string of the manifest (OciManifest enum, can be Image or ImageIndex)
   */
  pullManifest(imageRef: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Pull a blob from the registry by digest.
   * Returns: Buffer containing the blob data
   */
  pullBlob(imageRef: string, digest: string, auth?: AuthOptions | undefined | null): Promise<Buffer>
  /**
   * Push a blob to the registry.
   * The digest must be pre-calculated and provided by the caller.
   * Returns: The digest of the pushed blob
   * Note: oci-client 0.14 push_blob does NOT take auth parameter, but we accept it for API consistency
   */
  pushBlob(imageRef: string, data: Buffer, digest: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Push a manifest to the registry.
   * manifest_json: JSON string of the OCI manifest (OciManifest enum)
   * Returns: The manifest URL
   * Note: oci-client 0.14 push_manifest does NOT take auth parameter, but we accept it for API consistency
   */
  pushManifest(imageRef: string, manifestJson: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * List tags for an image repository.
   * n: Optional limit on number of tags to return
   * last: Optional last tag from previous request (for pagination)
   * Returns: JSON array of tag strings
   */
  listTags(imageRef: string, auth?: AuthOptions | undefined | null, n?: number | undefined | null, last?: string | undefined | null): Promise<Array<string>>
  /**
   * Pull manifest as raw bytes.
   * accepted_media_types: Optional array of accepted media types
   * Returns: Raw manifest bytes
   */
  pullManifestRaw(imageRef: string, auth?: AuthOptions | undefined | null, acceptedMediaTypes?: Array<string> | undefined | null): Promise<Buffer>
  /**
   * Push manifest as raw bytes.
   * manifest_bytes: Raw manifest bytes
   * content_type: Content-Type header value (e.g., "application/vnd.oci.image.manifest.v1+json")
   * Returns: The manifest URL
   * Note: oci-client 0.14 push_manifest_raw does NOT take auth parameter, but we accept it for API consistency
   */
  pushManifestRaw(imageRef: string, manifestBytes: Buffer, contentType: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Fetch the manifest digest without pulling the full manifest.
   * Returns: The manifest digest (sha256:...)
   */
  fetchManifestDigest(imageRef: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Pull manifest and config together.
   * Returns: JSON string containing manifest, digest, and config
   */
  pullManifestAndConfig(imageRef: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Pull referrers for an artifact (OCI 1.1 Referrers API).
   * artifact_type: Optional filter by artifact type
   * Returns: JSON string of referrers index
   * Note: oci-client 0.14 pull_referrers does NOT take auth parameter, but we accept it for API consistency
   */
  pullReferrers(imageRef: string, artifactType?: string | undefined | null, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Mount a blob from another repository (cross-repo blob mount).
   * from_ref: Source repository reference
   * digest: Blob digest to mount
   * Returns: Success message
   * Note: oci-client 0.14 mount_blob does NOT take auth parameter, but we accept it for API consistency
   */
  mountBlob(targetRef: string, fromRef: string, digest: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Push a manifest list (OCI Image Index) to the registry.
   * This is a convenience method specifically for pushing Image Indexes.
   * manifest_list_json: JSON string of OciImageIndex
   * Returns: The manifest URL
   */
  pushManifestList(imageRef: string, manifestListJson: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Pull an image manifest, automatically resolving platform if it's an Image Index.
   * Returns: JSON string of the resolved OciImageManifest
   */
  pullImageManifest(imageRef: string, auth?: AuthOptions | undefined | null): Promise<string>
  /**
   * Pull an image and return its data (layers, config).
   * accepted_media_types: Optional list of media types to accept for layers.
   * Returns: NapiImageData struct
   */
  pull(imageRef: string, auth?: AuthOptions | undefined | null, acceptedMediaTypes?: Array<string> | undefined | null): Promise<NapiImageData>
  /**
   * Push an image (layers, config, and optional manifest).
   * layers_json: JSON string of Vec<NapiImageLayer>
   * config_json: JSON string of NapiConfig
   * manifest_json: Optional JSON string of OciImageManifest
   * Returns: NapiPushResponse
   */
  push(imageRef: string, layersJson: string, configJson: string, auth?: AuthOptions | undefined | null, manifestJson?: string | undefined | null): Promise<NapiPushResponse>
}

export interface AuthOptions {
  username?: string
  password?: string
  token?: string
  useDockerConfig?: boolean
}

export interface NapiConfig {
  data: Buffer
  mediaType: string
  annotations?: Record<string, string>
}

export interface NapiImageData {
  layers: Array<NapiImageLayer>
  digest?: string
  config?: NapiConfig
}

export interface NapiImageLayer {
  data: Buffer
  mediaType: string
  annotations?: Record<string, string>
}

export interface NapiPushResponse {
  configUrl: string
  manifestUrl: string
}
